根据时间复杂度倒退算法：
O(1) 极少
O(logn) 二分法
O(根号n) 分解质因数
O(n) 高频
O(nlogn) 排序
O(n^2) 数组，枚举，动态规划
O(n^3) 数组，枚举，动态规划
O(2^n) 组合有关的搜索
O(n!)  排序有关的搜索

DFS： 1.非递归
	2.递归 ： 1.traverse
		2.divide and conquer
Binary tree非递归
  0.preorder 
    思想：one tree is composed of 3 part: root, all left, all right;
    一棵树可以看成只有一个当前点，其他所有子节点都是左或者右孩子。
    所以preorder分3步：
      1. root 入stack判断非空
      2. 右孩子入栈
      3. 左孩子入栈
        public List<Integer> preorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        List<Integer> preorder = new ArrayList<Integer>();
        
        if (root == null) {
            return preorder;
        }
        
        stack.push(root);
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            preorder.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
        
        return preorder;
    }
    
   inorder:
   
   1.找到最左边的点，过程中将所有点入Stack，返回并指向右孩子
   2.返回到他的父节点，返回并指向右孩子，
   循环
   public ArrayList<Integer> inorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        ArrayList<Integer> result = new ArrayList<Integer>();
        TreeNode curt = root;
        while (curt != null || !stack.empty()) {
            while (curt != null) {
                stack.add(curt);
                curt = curt.left;
            }
            curt = stack.peek();
            stack.pop();
            result.add(curt.val);
            curt = curt.right;
        }
        return result;
    }
    postOrder:
    public List<Integer> postorderTraversal(TreeNode root) {
	LinkedList<Integer> ans = new LinkedList<>();
	Stack<TreeNode> stack = new Stack<>();
	if (root == null) return ans;
	
	stack.push(root);
	while (!stack.isEmpty()) {
		TreeNode cur = stack.pop();
		ans.addFirst(cur.val);
		if (cur.left != null) {
			stack.push(cur.left);
		}
		if (cur.right != null) {
			stack.push(cur.right);
		} 
	}
	return ans;
}
递归的方法
1.traverse（ 一个人干活））
	以前序遍历为例子：
		3要素： 
	1.递归的定义：把root为根的前序遍历放进result  traverse(TreeNode root, ArrayList result){}//假设已经做好了
	2.递归的拆分：穿进去的参数越来越小
	3.递归的出口：结束条件（判断root == null）能解决大多问题
2.分治法：（小弟汇报）divide and conquer
	1.递归的定义：求出root为根的preorder并return
	2.递归的拆分：
	3.递归的出口：
	
	
  1.求max depth 
  用递归： int left = maxPathSum(root.left);
          int right = maxPathSum(root.right);
          return Math.max(left,right) + 1;
   balanced binary tree: Left tree is balanced, right tree is balanced and heigh difference <= 1
  
  2.求max value through a path in a tree     -1      return -1
                                           -2  -3
          public int maxPathSum(TreeNode root) 
          if(root = null){
            return Integer.MIN_VALUE;//负无穷大  因为找不到包含点的路径，如果求最小值return Integer.MAX_VALUE 
          }
          int left = maxPathSum(root.left);
          int right = maxPathSum(root.right);
          if(Math.max(right,left) < 0){
            return root.value;
          }
          else{
            return Math.max(right,left) + root.value;
          }
          //或者更简单的写法
          return Math.max(Math.max(left,right),0) + root.value;
          
          
    3.从任意节点出发到任意节点结束：          -3
                                        -2     -1     return max return -1
      1. 全在左边
      2.全在右边
      3.至少包含根节点
          分为3部分
          1.左边根节点到任意点
          2.根节点
          3。右边根节点到任意点
       类似于上一题，所以需要两个值， root2any 和 any2any
       private class ResultType{
        int root2any, any2any;
        ResultType(int root2any,int any2any){
          this.any2any = any2any;
          this.root2any = root2any;
        }
       }
       private ResultType helper(TreeNode root){
        if(root == null){
          return new ResultType(Integer.MIN_VALUE,Integer.MIN_VALUE);
         }
       }
       //Divide
       ResultType left = helper(root.left)// 求得左边的root2any 和any2any
       ResultType right = helper(root.right)//求得右边的
       //conquer
       //求得当前的点
       int root2any = Math.max(0,Math.max(left.root2any,right.root2any)) + root.value
       int any2any = Math.max(left.any2any,right.any2any);//在左边或右边
       any2any = Mathmax(any2any,
       Math.max(left.root2any,0) + root.value + Math.max(right.root2any,0));
       return new ResultType(root2any, any2any);
       public int maxPathSum(TreeNode node){
        ResultType result = helper(root);
        return result.any2any;
       }
       
  4.Binary Search Tree
    1.左子树 < root
    2.right >= root
    3. in- order traversal 升序
    4.in-order 不是升序的一定不是BST
    5.中序遍历是升序不一定是BST
       
   
   5. lowest common ancestor 二叉树
    问题先给left做，再给right做，别自己做
    
   6.Max average sub tree
   /**和path，Minimum Subtree这类题差不多，
         * 这一类的题目都可以这样做：
         * 开一个ResultType的变量result，
         * 来储存拥有最大average的那个node的信息。
         * 然后用分治法来遍历整棵树。
         * 一个小弟找左子数的average，一个小弟找右子树的average。
         * 然后通过这两个来计算当前树的average。
         * 同时，我们根据算出来的当前树的average决定要不要更新result。
         * 当遍历完整棵树的时候，
         * result里记录的就是拥有最大average的子树的信息。*/
7. Binary Tree Maximum Path Sum 
Given a binary tree, find the maximum path sum.

The path may start and end at any node in the tree.

两种情况：1.左子树里或者右子树里
2.包裹了root

但是为了计算第二种情况，仅仅使用any2any还不够，因为是一条路，root不能和any2any连接，so，need anyother variable : root2any
